#!/usr/bin/env bash
set -euo pipefail

die(){ echo "Error: $*" >&2; exit 1; }
have(){ command -v "$1" >/dev/null 2>&1; }

SCRIPT_DIR="$(cd -P "$(dirname "${BASH_SOURCE[0]:-$0}")" && pwd)"
REPO_DIR="$(cd -P "${SCRIPT_DIR}/.." && pwd)"

CONF_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/dndsr"
CONF_FILE="${CONF_DIR}/config.env"
CMDS_FILE="${CONF_DIR}/commands.txt"
BIN_DIR="${HOME}/.local/bin"
SHIM="${BIN_DIR}/dndsr"
BASH_COMP_DIR="${HOME}/.local/share/bash-completion/completions"
ZSH_COMP_DIR="${HOME}/.zsh/completions"

usage(){
cat <<'EOF'
dndsr-install — install host 'dndsr' shim that runs dndsR via container deps

USAGE
  tools/dndsr-install install --engine auto|apptainer|singularity|docker [--sif PATH | --image REF] [--rlib PATH] [--docker-platform PLATFORM]
  tools/dndsr-install doctor
  tools/dndsr-install uninstall

NOTES
  - dndsR package is installed into a host library (default ~/.dndsr/rlib) by running R inside the container.
  - Container is used ONLY for dependencies/tools; dndsR itself remains on host.
  - Repo path is recorded in config; keep the repo if you want auto-install/updates.

EXAMPLES
  # HPC (Apptainer)
  tools/dndsr-install install --engine apptainer --sif /path/to/dndsr.sif

  # Docker
  tools/dndsr-install install --engine docker --image scrumpis/dndsr:0.2.0

  # Then:
  dndsr --help
  dndsr append-annotations -C comparisons.tsv ...

EOF
}

detect_engine(){
  if have apptainer; then echo "apptainer"; return 0; fi
  if have singularity; then echo "singularity"; return 0; fi
  if have docker; then echo "docker"; return 0; fi
  return 1
}

abspath(){
  local p="$1"
  [[ -n "$p" ]] || { echo ""; return 0; }

  # Prefer realpath if available
  if have realpath; then
    realpath "$p"
    return 0
  fi
  # Fallback: cd + pwd
  if [[ -d "$p" ]]; then
    (cd "$p" && pwd -P)
  else
    local d
    d="$(dirname "$p")"
    (cd "$d" && printf '%s/%s\n' "$(pwd -P)" "$(basename "$p")")
  fi
}

path_has_local_bin(){
  case ":$PATH:" in
    *":$HOME/.local/bin:"*) return 0 ;;
    *) return 1 ;;
  esac
}

detect_shell(){
  if [[ -n "${SHELL:-}" ]]; then basename "$SHELL"; else echo "sh"; fi
}

ensure_zsh_completion(){
  local zshrc="${HOME}/.zshrc"

  # Ensure zshrc exists
  [[ -f "$zshrc" ]] || : > "$zshrc"

  # Ensure fpath includes our completion dir + initialize completion
  if ! grep -q 'fpath+=("\$HOME/.zsh/completions")' "$zshrc" 2>/dev/null; then
    cat >> "$zshrc" <<'ZSH'

# dndsr completion
fpath+=("$HOME/.zsh/completions")
autoload -Uz compinit && compinit
ZSH
  fi
}

write_config(){
  local engine="$1" sif="$2" image="$3" rlib="$4" docker_platform="${5:-}"
  mkdir -p "$CONF_DIR" "$BIN_DIR" "$rlib" || die "Failed to create install dirs"

  # Canonicalize paths so config works from ANY working directory
  local repo_abs rlib_abs sif_abs
  repo_abs="$(abspath "$REPO_DIR")"
  rlib_abs="$(abspath "$rlib")"
  sif_abs=""
  if [[ -n "$sif" ]]; then
    sif_abs="$(abspath "$sif")"
  fi

  cat >"$CONF_FILE" <<EOF
# dndsr host shim config
DNDSR_ENGINE=${engine}
DNDSR_SIF=${sif_abs}
DNDSR_IMAGE=${image}
DNDSR_DOCKER_PLATFORM=${docker_platform}

# Host library where dndsR will be installed (MUST be writable)
DNDSR_RLIB=$rlib_abs

# Path to dndsR repo (used to install/update package)
DNDSR_REPO=$repo_abs

# Workdir inside container for runtime execution
DNDSR_WORKDIR=/work

# Optional: extra binds (comma-separated host:container pairs)
# DNDSR_BINDS=/scratch:/scratch,/mnt:/mnt

# Optional: extra engine args
# DNDSR_EXTRA_ARGS=
EOF
  chmod 600 "$CONF_FILE" || true
}

write_shim(){
  mkdir -p "$BIN_DIR" || true
  cat >"$SHIM" <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

die(){ echo "Error: $*" >&2; exit 1; }
have(){ command -v "$1" >/dev/null 2>&1; }

CONF_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/dndsr/config.env"
[[ -f "$CONF_FILE" ]] || die "Missing config: $CONF_FILE. Run: tools/dndsr-install install ..."

# shellcheck disable=SC1090
source "$CONF_FILE"

ENGINE="${DNDSR_ENGINE:-}"
SIF="${DNDSR_SIF:-}"
IMAGE="${DNDSR_IMAGE:-}"
RLIB="${DNDSR_RLIB:-}"
REPO="${DNDSR_REPO:-}"
WORKDIR="${DNDSR_WORKDIR:-/work}"
BINDS="${DNDSR_BINDS:-}"
EXTRA="${DNDSR_EXTRA_ARGS:-}"
DOCKER_PLATFORM="${DNDSR_DOCKER_PLATFORM:-}"
platform_args=()
[[ -n "$DOCKER_PLATFORM" ]] && platform_args=( --platform "$DOCKER_PLATFORM" )

[[ -n "$ENGINE" ]] || die "DNDSR_ENGINE not set in config"
[[ -n "$RLIB" ]]   || die "DNDSR_RLIB not set in config"
mkdir -p "$RLIB" || die "Failed to create DNDSR_RLIB: $RLIB"
[[ -w "$RLIB" ]] || die "DNDSR_RLIB not writable: $RLIB"

RUNNER="${RLIB}/dndsR/exec/dndsr"
META="${RLIB}/.dndsR.installmeta"

# Compute source hash (best-effort) from repo to detect changes
src_hash(){
  local sum=""
  if have sha256sum; then sum="sha256sum"
  elif have shasum; then sum="shasum -a 256"
  elif have md5sum; then sum="md5sum"
  else echo ""; return 0; fi

  (
    cd "$REPO" 2>/dev/null || exit 1
    find DESCRIPTION NAMESPACE R inst man tools -type f 2>/dev/null \
      | LC_ALL=C sort \
      | xargs $sum \
      | ${sum%% *} \
      | awk '{print $1}'
  ) 2>/dev/null || true
}

need_install(){
  # install if runner missing
  [[ -x "$RUNNER" ]] || return 0

  # if repo is missing, cannot compare; assume ok
  [[ -d "$REPO" ]] || return 1

  local desc="$REPO/DESCRIPTION"
  [[ -f "$desc" ]] || return 1

  local ver hash prev_ver prev_hash
  ver="$(awk -F': *' '$1=="Version"{print $2}' "$desc" 2>/dev/null || true)"
  hash="$(src_hash || true)"

  [[ -f "$META" ]] || return 0
  read -r prev_ver prev_hash <"$META" 2>/dev/null || true

  # if we can’t parse version, don't force reinstall
  [[ -n "$ver" ]] || return 1

  # reinstall if version changed, or hash changed (when available)
  if [[ "$prev_ver" != "$ver" ]]; then return 0; fi
  if [[ -n "$hash" && "$prev_hash" != "$hash" ]]; then return 0; fi

  return 1
}

# Build engine-specific bind args.
build_bind_args(){
  local -n _out=$1
  _out=()

  # user-defined binds
  if [[ -n "$BINDS" ]]; then
    IFS=',' read -r -a pairs <<< "$BINDS"
    for p in "${pairs[@]}"; do
      [[ -n "$p" ]] || continue
      case "$ENGINE" in
        apptainer|singularity) _out+=( --bind "$p" ) ;;
        docker) _out+=( -v "$p" ) ;;
      esac
    done
  fi
}

# Run a command inside container with repo + rlib mounted
run_in_container(){
  local -a bind_args extra_args
  build_bind_args bind_args

  # shellcheck disable=SC2206
  extra_args=(${EXTRA:-})

  local pwd_real; pwd_real="$(pwd -P)"

  case "$ENGINE" in
    apptainer|singularity)
      have "$ENGINE" || die "Engine not found: $ENGINE"
      [[ -n "$SIF" ]] || die "DNDSR_SIF is empty in config"
      [[ -f "$SIF" ]] || die "SIF not found: $SIF"
      [[ -d "$REPO" ]] || die "Repo not found: $REPO (needed to install/update)"

      exec "$ENGINE" exec \
        "${extra_args[@]}" \
        --bind "${pwd_real}:${WORKDIR}" \
        --bind "${RLIB}:${RLIB}" \
        --bind "${REPO}:${REPO}" \
        "${bind_args[@]}" \
        "$SIF" \
        bash -lc "$1" bash
      ;;

    docker)
      have docker || die "docker not found"
      [[ -n "$IMAGE" ]] || die "DNDSR_IMAGE is empty in config"
      [[ -d "$REPO" ]] || die "Repo not found: $REPO (needed to install/update)"

      exec docker run --rm \
        "${platform_args[@]}" \
        -u "$(id -u)":"$(id -g)" \
        -v "${pwd_real}:${WORKDIR}" \
        -v "${RLIB}:${RLIB}" \
        -v "${REPO}:${REPO}" \
        -w "${WORKDIR}" \
        "${bind_args[@]}" \
        "${extra_args[@]}" \
        "$IMAGE" \
        bash -lc "$1"
      ;;

    *)
      die "Unknown engine: $ENGINE"
      ;;
  esac
}

install_if_needed(){
  # allow user to disable auto-install at runtime
  local auto="${DNDSR_AUTO_INSTALL:-1}"
  [[ "$auto" == "1" ]] || return 0

  if need_install; then
    [[ -d "$REPO" ]] || die "dndsR not installed and repo missing; cannot install."
    local desc="$REPO/DESCRIPTION"
    local ver hash
    ver="$(awk -F': *' '$1=="Version"{print $2}' "$desc" 2>/dev/null || true)"
    hash="$(src_hash || true)"

    echo "[dndsr] Installing/updating dndsR into: $RLIB" >&2

    # Run R install inside container; write meta into the same mounted RLIB
    local cmd
    cmd=$(
      cat <<CMD
set -euo pipefail
export R_PROFILE=/dev/null R_PROFILE_USER=/dev/null R_ENVIRON_USER=/dev/null BSPM_DISABLE=1
Rscript --vanilla -e "install.packages(normalizePath('${REPO}'), repos=NULL, type='source', lib='${RLIB}', INSTALL_opts=c('--clean','--preclean'))"
printf '%s %s\n' '${ver:-unknown}' '${hash:-nohash}' > '${META}'
CMD
    )

    # Run and return to current shell (do not exec so we can continue)
    if [[ "$ENGINE" == "docker" ]]; then
      docker run --rm \
        "${platform_args[@]}" \
        -u "$(id -u)":"$(id -g)" \
        -v "${RLIB}:${RLIB}" \
        -v "${REPO}:${REPO}" \
        "${IMAGE}" \
        bash -lc "$cmd" >/dev/null
    else
      "$ENGINE" exec \
        --bind "${RLIB}:${RLIB}" \
        --bind "${REPO}:${REPO}" \
        "${SIF}" \
        bash -lc "$cmd" >/dev/null
    fi
  fi
}

# Special shim-local commands
case "${1:-}" in
  config)
    echo "engine=$ENGINE"
    echo "sif=$SIF"
    echo "image=$IMAGE"
    echo "rlib=$RLIB"
    echo "repo=$REPO"
    echo "workdir=$WORKDIR"
    echo "binds=$BINDS"
    echo "extra_args=$EXTRA"
    exit 0
    ;;
  doctor)
    echo "=== dndsr doctor ==="
    echo "engine:   $ENGINE"
    echo "sif:      ${SIF:-<none>}"
    echo "image:    ${IMAGE:-<none>}"
    echo "rlib:     $RLIB"
    echo "repo:     ${REPO:-<none>}"
    echo "runner:   $RUNNER"
    echo "docker_platform: ${DOCKER_PLATFORM:-<default>}"
    echo "auto-install: ${DNDSR_AUTO_INSTALL:-1}"
    echo
    if [[ -x "$RUNNER" ]]; then
      echo "[ok] runner exists"
    else
      echo "[warn] runner missing (will install if repo is available)"
    fi
    echo
    echo "[test] dndsr --help (container invocation)"
    # ensure install then try help
    ;;
esac

# Ensure package installed (best-effort; uses repo if needed)
install_if_needed

# Now run the actual CLI inside container from the host-installed runner
[[ -x "$RUNNER" ]] || die "Runner not found after install: $RUNNER"

# Build binds for runtime and execute
build_bind_args bind_args
# shellcheck disable=SC2206
extra_args=(${EXTRA:-})
pwd_real="$(pwd -P)"

case "$ENGINE" in
  apptainer|singularity)
    exec "$ENGINE" exec \
      "${extra_args[@]}" \
      --bind "${pwd_real}:${WORKDIR}" \
      --bind "${RLIB}:${RLIB}" \
      "${bind_args[@]}" \
      "${SIF}" \
      bash -lc "export R_LIBS_USER='${RLIB}'; cd '${WORKDIR}'; '${RUNNER}' \"\$@\"" bash "$@"
    ;;
  docker)
    exec docker run --rm \
      "${platform_args[@]}" \
      -u "$(id -u)":"$(id -g)" \
      -v "${pwd_real}:${WORKDIR}" \
      -v "${RLIB}:${RLIB}" \
      -w "${WORKDIR}" \
      "${bind_args[@]}" \
      "${extra_args[@]}" \
      "${IMAGE}" \
      bash -lc "export R_LIBS_USER='${RLIB}'; '${RUNNER}' \"\$@\"" bash "$@"
    ;;
  *)
    die "Unknown engine: $ENGINE"
    ;;
esac
EOF
  chmod +x "$SHIM" || die "Failed to chmod +x $SHIM"
}

write_commands_cache(){
  # Generate a stable command list ONCE at install time so completion does not
  # depend on container availability / SIF path / engine.
  mkdir -p "$CONF_DIR" || true

  # Try to run the just-installed shim (which will install dndsR if needed)
  if "$SHIM" __commands >/dev/null 2>&1; then
    "$SHIM" __commands > "$CMDS_FILE" || true
  else
    # If it fails (engine not available yet), create empty file; user can re-run install later
    : > "$CMDS_FILE"
  fi
}

install_completion(){
  mkdir -p "$BASH_COMP_DIR" "$ZSH_COMP_DIR" || true

  cat >"${BASH_COMP_DIR}/dndsr" <<EOF
# bash completion for dndsr (subcommands only)
# Uses cached commands at: ${CMDS_FILE}
_dndsr_complete() {
  local cur
  cur="\${COMP_WORDS[\${COMP_CWORD}]}"

  if [[ \${COMP_CWORD} -eq 1 ]]; then
    local cmds
    cmds="\$(cat "${CMDS_FILE}" 2>/dev/null || true)"
    COMPREPLY=( \$(compgen -W "\$cmds" -- "\$cur") )
    return 0
  fi

  COMPREPLY=( \$(compgen -f -- "\$cur") )
  return 0
}
complete -F _dndsr_complete dndsr
EOF

  cat >"${ZSH_COMP_DIR}/_dndsr" <<EOF
#compdef dndsr
# Uses cached commands at: ${CMDS_FILE}
_dndsr() {
  local -a cmds
  cmds=( "\${(@f)\$(cat "${CMDS_FILE}" 2>/dev/null)}" )
  if (( CURRENT == 2 )); then
    _describe 'command' cmds
  else
    _files
  fi
}
_dndsr "\$@"
EOF
}

doctor(){
  echo "=== dndsr-install doctor ==="
  echo "repo:    $REPO_DIR"
  echo "config:  $CONF_FILE"
  echo "shim:    $SHIM"
  [[ -f "$CONF_FILE" ]] || { echo "  <missing config>"; return 1; }
  # shellcheck disable=SC1090
  source "$CONF_FILE"
  echo "engine:  ${DNDSR_ENGINE:-<unset>}"
  echo "sif:     ${DNDSR_SIF:-<unset>}"
  echo "image:   ${DNDSR_IMAGE:-<unset>}"
  echo "rlib:    ${DNDSR_RLIB:-<unset>}"
  echo "repo:    ${DNDSR_REPO:-<unset>}"
  echo "docker_platform: ${DNDSR_DOCKER_PLATFORM:-<default>}"
  echo
  echo "PATH has ~/.local/bin?  $(echo "$PATH" | tr ':' '\n' | grep -qx "$HOME/.local/bin" && echo yes || echo no)"
}

uninstall(){
  rm -f "$SHIM" || true
  rm -f "${BASH_COMP_DIR}/dndsr" || true
  rm -f "${ZSH_COMP_DIR}/_dndsr" || true
  rm -f "$CONF_FILE" || true
  rm -f "$CMDS_FILE" || true
  rmdir "$CONF_DIR" 2>/dev/null || true
  echo "Uninstalled shim/config/completions."
}

cmd="${1:-}"
shift || true

case "$cmd" in
  install)
    engine="auto"; sif=""; image=""; rlib="${HOME}/.dndsr/rlib"; docker_platform=""
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --engine) engine="${2:-}"; shift 2 ;;
        --sif)    sif="${2:-}"; shift 2 ;;
        --image)  image="${2:-}"; shift 2 ;;
        --rlib)   rlib="${2:-}"; shift 2 ;;
        --docker-platform) docker_platform="${2:-}"; shift 2 ;;
        -h|--help) usage; exit 0 ;;
        *) die "Unknown arg: $1" ;;
      esac
    done

    if [[ "$engine" == "auto" ]]; then
      engine="$(detect_engine)" || die "Could not detect engine. Install apptainer/singularity or docker, or pass --engine."
    fi

    case "$engine" in
      apptainer|singularity)
        [[ -n "$sif" ]] || die "--sif is required for $engine"
        ;;
      docker)
        [[ -n "$image" ]] || die "--image is required for docker"
        ;;
      *) die "Invalid engine: $engine" ;;
    esac

    write_config "$engine" "$sif" "$image" "$rlib" "$docker_platform"
    write_shim
    write_commands_cache
    install_completion || true
    ensure_zsh_completion || true

    echo
    echo "Installed dndsr CLI to:"
    echo "  $SHIM"
    echo
    echo "Cached subcommands for completion:"
    echo "  $CMDS_FILE"
    echo

    if path_has_local_bin; then
      echo "~/.local/bin is already on PATH"
    else
      echo "~/.local/bin is not on PATH"
      shell="$(detect_shell)"
      echo
      case "$shell" in
        bash|sh)
          echo "Add it (bash):"
          echo "  echo 'export PATH=\"\$HOME/.local/bin:\$PATH\"' >> ~/.bashrc"
          echo "  source ~/.bashrc"
          ;;
        zsh)
          echo "Add it (zsh):"
          echo "  echo 'export PATH=\"\$HOME/.local/bin:\$PATH\"' >> ~/.zshrc"
          echo "  source ~/.zshrc"
          ;;
        fish)
          echo "Add it (fish):"
          echo "  fish_add_path ~/.local/bin"
          ;;
        *)
          echo "Add ~/.local/bin to your PATH in your shell config, then restart your shell."
          ;;
      esac
      echo
    fi

    echo "To enable completion in this shell, either open a new terminal or run:"
    echo "  source ~/.bashrc   # bash"
    echo "  source ~/.zshrc    # zsh"
    echo
    echo "If you previously got 'command not found', clear shell command cache:"
    echo "  hash -r 2>/dev/null || true"
    echo "  rehash 2>/dev/null || true"
    echo
    echo "Verify:"
    echo "  dndsr --help"
    ;;

  doctor) doctor ;;
  uninstall) uninstall ;;
  ""|-h|--help) usage ;;
  *) usage; die "Unknown command: $cmd" ;;
esac
