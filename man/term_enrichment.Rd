% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/term_enrichment.R
\name{term_enrichment}
\alias{term_enrichment}
\title{Term enrichment (Fisher test) for query/subject term columns in dN/dS results}
\usage{
term_enrichment(
  dnds_annot_file = NULL,
  comparison_file = NULL,
  output_dir = getwd(),
  terms = NULL,
  exclude_terms = c("ipr", "go"),
  sides = c("query", "subject"),
  pos_threshold = 1,
  max_dnds = 10,
  filter_expr = NULL,
  make_plots = TRUE,
  top_n = 20,
  drop_rows_without_term = TRUE,
  min_total = 0,
  min_pos = 0,
  fdr_method = c("BH", "IHW", "qvalue", "none"),
  alpha = 0.05,
  term_seps = c(";", "|", ","),
  term_blocklist = c("attributes", "attribute", "attr", "notes", "note", "description",
    "product", "name", "id", "gene_id", "transcript_id", "parent", "dbxref", "source",
    "target", "type", "seqname", "seqid", "start", "end", "strand", "phase", "biotype",
    "class", "len", "gff_start", "gff_end", "gff_seqname"),
  exclude_ids = NULL,
  term_trees = NULL,
  exclude_descendants = FALSE,
  exclude_descendants_depth = Inf,
  exclude_descendants_limit = 5000,
  term_metadata = NULL,
  keep_unmatched_ids = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{dnds_annot_file}{Path to a single \verb{<comp>_dnds_annot.tsv} file (single mode).
If provided, \code{comparison_file} must be NULL.}

\item{comparison_file}{Path to whitespace-delimited file (tabs/spaces; header or not)
with columns: \verb{comparison_name, query_fasta, query_gff, subject_fasta, subject_gff}.
In batch mode, each comparison is read from:
\code{file.path(output_dir, comparison_name, paste0(comparison_name, "_dnds_annot.tsv"))}.}

\item{output_dir}{Root directory containing per-comparison folders (batch mode).}

\item{terms}{Optional character vector of term types to test (suffixes like
\code{c("kegg","pfam")}). Default NULL = auto-detect from \verb{q_*}/\verb{s_*} columns.}

\item{exclude_terms}{Character vector of term types to exclude entirely from testing
(applies to auto-detect and explicit \code{terms}). Default \code{c("ipr","go")}.
Set to NULL to allow them.}

\item{sides}{Character vector among \code{c("query","subject")}. Default both.}

\item{pos_threshold}{Numeric. \code{dNdS > pos_threshold} defines "positive" (default 1).}

\item{max_dnds}{Numeric. Drops rows with \code{dNdS >= max_dnds} or NA \code{dNdS} (default 10).}

\item{filter_expr}{Optional character; a logical expression evaluated in the data
to further filter rows (e.g., \code{"q_seqname == s_seqname"}). Default NULL.}

\item{make_plots}{Logical; if TRUE, write a top-N bubble plot per result (default TRUE).}

\item{top_n}{Integer; number of rows to include in the plot (default 20).}

\item{drop_rows_without_term}{Logical; if TRUE (default), rows with no term in the
tested column are removed from BOTH positives and background before counting.}

\item{min_total}{Minimum total occurrences (pos+nonpos) required for a term (default 0).}

\item{min_pos}{Minimum positive occurrences required for a term (default 0).}

\item{fdr_method}{One of \code{"BH"}, \code{"IHW"}, \code{"qvalue"}, \code{"none"}. Default \code{"BH"}.}

\item{alpha}{FDR level for IHW weighting (default 0.05).}

\item{term_seps}{Candidate separators to auto-detect per column
(default \code{c(";", "|", ",")}).}

\item{term_blocklist}{Character vector of suffixes to ignore as term families.
(e.g. fields like \code{id}, \code{name}, \code{start}, \code{end}, etc.) Defaults are conservative.}

\item{exclude_ids}{Either a character vector of term IDs to exclude globally (all types),
or a named list mapping \verb{term_type -> character vector} of IDs to exclude for that type.
Default NULL.}

\item{term_trees}{Optional tree(s) enabling descendant exclusion. Either:
(1) a path/data.frame edgelist (two columns: parent, child) applied to all types, or
(2) a named list mapping \verb{term_type -> (path or data.frame edgelist)}.}

\item{exclude_descendants}{Logical; if TRUE, expands \code{exclude_ids} per type using
descendants found in \code{term_trees}. Default FALSE.}

\item{exclude_descendants_depth}{Integer depth limit when expanding descendants.
\code{1} = direct children; \code{Inf} = full subtree. Default \code{Inf}.}

\item{exclude_descendants_limit}{Hard cap on number of excluded nodes per type to
avoid accidental mass exclusion. Default 5000.}

\item{term_metadata}{Optional metadata join(s). Either:
(1) a path/data.frame with columns \code{ID}, \code{NAME} (optional \code{DEFINITION}) applied to all types, or
(2) a named list mapping \verb{term_type -> (path or data.frame)}.}

\item{keep_unmatched_ids}{Logical; if TRUE (default), keep terms lacking metadata.
If FALSE, rows without a metadata NAME are dropped.}

\item{verbose}{Logical; if TRUE, prints detection and audit messages. Default TRUE.}
}
\value{
(Invisibly) a character vector of output TSV paths.
In batch mode, this includes all comparisons. In single mode, paths for that file.
TSV columns include: term, term_type, side, pos_count, nonpos_count, pos_total,
nonpos_total, odds_ratio, p_value, p_adj, total_count, enrichment, and optionally
term_name, term_def, label.
}
\description{
Reads a \verb{<comparison>/<comparison>_dnds_annot.tsv} file and tests enrichment of
annotation terms found in \verb{q_*} / \verb{s_*} columns among positively selected rows
(\code{dNdS > pos_threshold}) versus the filtered background.
}
\details{
Term "types" are inferred from suffixes of \verb{q_*}/\verb{s_*} columns (e.g., \code{q_pfam},
\code{s_kegg}). By default, \code{ipr} and \code{go} are excluded from this generic routine.
(Use dedicated functions for IPR/GO if you have them.)

For each term type and side, runs a one-sided Fisher exact test ("greater") on
term presence/absence counts and reports odds ratio, p-value, and adjusted p-value.
Optionally joins metadata (NAME/DEFINITION) and supports term-ID exclusion and
descendant exclusion using a parent-child tree.
}
